\documentclass[10pt,a4paper]{article}
\usepackage[UTF8]{ctex}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{float}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usepackage{subcaption}
\usepackage{setspace}
\usepackage{titlesec}

% 页边距设置 - 更紧凑
\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

% 行距设置
\setstretch{1.1}

% 段落间距
\setlength{\parskip}{0.3em}
\setlength{\parindent}{2em}

% 列表间距设置 - 更紧凑
\setlist{nosep,leftmargin=2em}
\setlist[itemize]{itemsep=0pt,parsep=0pt,topsep=2pt}
\setlist[enumerate]{itemsep=0pt,parsep=0pt,topsep=2pt}

% 章节标题间距 - 更紧凑
\titlespacing*{\section}{0pt}{1.5ex plus 0.5ex minus 0.2ex}{1ex plus 0.2ex}
\titlespacing*{\subsection}{0pt}{1.2ex plus 0.4ex minus 0.2ex}{0.8ex plus 0.2ex}
\titlespacing*{\subsubsection}{0pt}{1ex plus 0.3ex minus 0.1ex}{0.5ex plus 0.1ex}
\titlespacing*{\paragraph}{0pt}{0.8ex plus 0.2ex minus 0.1ex}{1em}

% 代码样式 - 更小字体
\lstset{
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    tabsize=2,
    aboveskip=0.5em,
    belowskip=0.5em
}

% 图表间距
\setlength{\floatsep}{8pt plus 2pt minus 2pt}
\setlength{\textfloatsep}{8pt plus 2pt minus 2pt}
\setlength{\intextsep}{8pt plus 2pt minus 2pt}
\setlength{\abovecaptionskip}{4pt}
\setlength{\belowcaptionskip}{2pt}

% 表格内容更紧凑
\renewcommand{\arraystretch}{0.9}

\title{\textbf{实践项目:仓库管理员(Warehouse Runner)} \\ \Large 研习报告}
\author{姓名:卢祥云 \\ 学号:1120230944 \\ 1120230944@bit.edu.cn}
\date{\today}

\begin{document}

\maketitle

%====================================================================
% 报告概览
%====================================================================
\section*{报告概览}
\vspace{-0.5em}

本报告基于ROS 2 Humble和Nav2导航框架,在TIAGo机器人仿真平台上开展导航性能优化研究。
\vspace{-0.3em}
\begin{itemize}[leftmargin=1.5em,itemsep=1pt]
\item \textbf{第一部分}:Nav2框架架构、TIAGo平台、Gazebo仿真环境、遥控UI与自动化测试脚本。
\item \textbf{第二部分}:6组参数配置对比实验,baseline以100\%成功率和0.453 m/s取得最佳表现。
\item \textbf{第三部分}:DWB/RPP/MPPI/Stanley四种控制器对比,RPP效率最高,MPPI精度最优;详述Stanley插件开发与参数设计。
\item \textbf{第四部分}:动态多控制器行为树设计,通过Blackboard实现三阶段控制器切换。
\item \textbf{第五部分}:主要结论与未来展望。
\end{itemize}
\vspace{-0.5em}

\tableofcontents
\newpage

%====================================================================
% 第一部分:系统概述与环境介绍
%====================================================================
\section{系统概述与环境介绍}

本部分介绍项目的核心技术栈,包括Nav2导航框架、TIAGo机器人平台、仿真环境以及系统整体架构。

%--------------------------------------------------------------------
\subsection{Nav2导航框架}

Nav2(Navigation2)是ROS 2的官方导航堆栈,为移动机器人提供完整的自主导航解决方案。其设计强调模块化和可扩展性——所有核心功能以插件形式实现,用户可根据需要替换默认组件或添加自定义功能。Nav2的核心架构如图1所示,采用分层设计,顶层由行为树导航器(BT Navigator)协调,下层包含规划、控制、感知等功能模块。

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    box/.style={rectangle, draw, minimum width=3cm, minimum height=0.8cm, align=center},
    bigbox/.style={rectangle, draw, minimum width=10cm, minimum height=1cm, align=center, fill=blue!10},
    arrow/.style={->, thick}
]
    \node[bigbox] (bt) at (0,4) {BT Navigator(行为树导航器)};
    \node[box, fill=green!20] (planner) at (-4,2) {Planner Server\\全局规划器};
    \node[box, fill=green!20] (controller) at (0,2) {Controller Server\\局部控制器};
    \node[box, fill=green!20] (behavior) at (4,2) {Behavior Server\\恢复行为};
    \node[box, fill=orange!20] (global_cm) at (-2,0) {Global Costmap\\全局代价地图};
    \node[box, fill=orange!20] (local_cm) at (2,0) {Local Costmap\\局部代价地图};
    \node[box, fill=yellow!20] (amcl) at (-4,-2) {AMCL\\自适应蒙特卡洛定位};
    \node[box, fill=yellow!20] (map) at (0,-2) {Map Server\\地图服务器};
    \node[box, fill=yellow!20] (slam) at (4,-2) {SLAM Toolbox\\建图工具};
    \draw[arrow] (bt) -- (planner);
    \draw[arrow] (bt) -- (controller);
    \draw[arrow] (bt) -- (behavior);
    \draw[arrow] (planner) -- (global_cm);
    \draw[arrow] (controller) -- (local_cm);
    \draw[arrow] (global_cm) -- (map);
    \draw[arrow] (local_cm) -- (amcl);
\end{tikzpicture}
\caption{Nav2系统架构示意图}
\end{figure}

\subsubsection{核心组件}

\textbf{行为树导航器(BT Navigator)}是Nav2的核心协调模块,使用行为树管理导航任务的执行流程。相比传统有限状态机,行为树具有模块化、可复用、易调试和支持动态切换等优势。Nav2默认使用\texttt{navigate\_w\_replanning\_and\_recovery.xml}配置,实现带重规划和恢复机制的导航流程。

\textbf{全局路径规划器(Planner Server)}负责计算从当前位置到目标点的全局路径。Nav2提供多种规划算法:NavFn Planner采用经典的Dijkstra/A*算法,稳定可靠;Smac Planner系列支持2D、Hybrid-A*和State Lattice等变体,可考虑运动学约束;Theta* Planner能产生更平滑的路径。本项目默认使用NavFn Planner。

\textbf{局部控制器(Controller Server)}负责跟踪全局路径并生成实时速度指令。本项目涉及三种控制器:(1) \textbf{DWB控制器}基于动态窗口法,在速度空间中采样可行轨迹并通过多个评价函数(Critics)综合评分选择最优控制,主要参数包括最大速度、轨迹仿真时间和速度采样数量;(2) \textbf{RPP控制器}(Regulated Pure Pursuit)是改进的纯追踪控制器,增加了根据路径曲率、障碍物距离和目标点距离自动调节速度的机制;(3) \textbf{MPPI控制器}(Model Predictive Path Integral)基于模型预测和路径积分,使用蒙特卡洛采样预测多条轨迹并加权平均,计算量较大但效果更优。

\textbf{代价地图(Costmap)}是路径规划和避障的基础。系统维护两种代价地图:全局代价地图覆盖整个已知环境,包含静态地图层、障碍物层和膨胀层,用于全局路径规划;局部代价地图是以机器人为中心的滚动窗口,实时更新传感器观测,用于局部避障和控制。

\textbf{定位系统(AMCL)}使用自适应蒙特卡洛定位算法,通过粒子滤波实现机器人定位。其工作流程为:初始化时在地图上分布大量粒子表示假设位姿,根据里程计信息移动粒子(预测),根据激光扫描与地图匹配程度为粒子赋权重(更新),最后通过重采样保留高权重粒子。

\textbf{恢复行为(Behavior Server)}在导航陷入困境时尝试使机器人脱困,包括原地旋转(Spin)扫描周围环境、后退指定距离(BackUp)、沿当前方向行驶(DriveOnHeading)以及等待障碍物移开(Wait)等行为。

%--------------------------------------------------------------------
\subsection{TIAGo机器人平台}

TIAGo是PAL Robotics公司开发的服务机器人平台,专为研究和商业应用设计。该机器人采用高度模块化设计,可根据需求配置不同硬件组件。

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]
    \draw[fill=gray!30] (-1.5,-0.5) rectangle (1.5,0.5);
    \node at (0,0) {移动底盘};
    \draw[fill=blue!20] (-0.3,0.5) rectangle (0.3,3);
    \node[rotate=90] at (0,1.75) {升降柱};
    \draw[fill=orange!30] (-0.8,3) rectangle (0.8,4);
    \node at (0,3.5) {头部};
    \draw[fill=green!20, dashed] (0.3,2) -- (2,2.5) -- (2.5,1.5) -- (1,1.2) -- cycle;
    \node at (1.5,1.8) {\small 机械臂};
    \draw[<-] (-1.5,0) -- (-2.5,0) node[left] {PMB2底盘};
    \draw[<-] (0.8,3.5) -- (2,3.5) node[right] {RGB-D相机};
    \draw[<-] (-0.3,2) -- (-2,2) node[left] {激光雷达};
\end{tikzpicture}
\caption{TIAGo机器人结构示意图}
\end{figure}

\subsubsection{硬件组成与运动学模型}

TIAGo采用PMB2差速驱动底盘,最大前进速度1.0 m/s,最大旋转速度1.0 rad/s,底盘直径约54cm,机器人半径0.275m(用于导航避障)。差速驱动的运动学模型为:
\begin{equation}
v = \frac{v_r + v_l}{2}, \quad \omega = \frac{v_r - v_l}{L}
\end{equation}
其中$v_r$和$v_l$分别为左右轮速度,$L$为轮距。

传感器方面,底盘前部安装2D激光雷达(base\_laser\_link),相对底盘偏移x=0.202m、z=-0.004m,扫描范围270-360度,最大探测距离20m,数据发布到\texttt{/scan}话题。头部配备RGB-D深度相机(如Orbbec Astra或Intel RealSense),用于物体识别和3D感知。TIAGo还可选配7自由度机械臂,集成MoveIt2运动规划框架,本项目使用无臂版本(no-arm)以简化导航测试。

\subsubsection{坐标系与软件架构}

TIAGo的坐标系结构遵循REP-105标准,形成如下TF树:\texttt{map}(全局固定坐标系,由AMCL发布)$\to$\texttt{odom}(里程计坐标系,连续但会漂移)$\to$\texttt{base\_footprint}(底盘投影到地面)$\to$\texttt{base\_link}(底盘中心)$\to$\texttt{base\_laser\_link}(激光雷达)等。

本项目的TIAGo软件包结构包括:核心包\texttt{tiago\_robot}(模型描述、启动文件、控制器配置)、导航包\texttt{tiago\_navigation}(2D导航、激光和RGBD传感器配置)、仿真包\texttt{tiago\_simulation}(Gazebo仿真配置)以及PAL导航参数包(包含\texttt{tiago\_nav2.yaml}配置文件)。

在Gazebo中通过\texttt{ros2 run ros\_gz\_sim create}命令加载TIAGo的SDF模型,使用\texttt{ros\_gz\_bridge}将Gazebo话题桥接到ROS 2,主要控制接口包括速度指令(\texttt{/cmd\_vel})、里程计(\texttt{/odom})、激光扫描(\texttt{/scan})和关节状态(\texttt{/joint\_states})。

%--------------------------------------------------------------------
\subsection{仿真环境与工具链}

\subsubsection{仓库仿真环境与SLAM建图}

本项目使用Gazebo Sim构建仓库仿真环境,世界定义文件位于\texttt{map/turtlebot4\_gz\_bringup/worlds/warehouse.sdf}。仓库环境包含:仓库主体(OpenRobotics/Warehouse)、5个大型货架和8个小型货架(MovAi)、4个护栏(Jersey Barrier)以及椅子等障碍物。物理引擎采用ODE,步长0.003秒,实时因子1.0。

地图构建使用SLAM Toolbox进行2D激光SLAM,支持在线同步/异步建图、离线地图编辑、地图序列化与继续建图、回环检测与图优化。建图流程为:启动Gazebo仿真和TIAGo机器人$\to$运行slam\_toolbox的sync\_slam\_toolbox\_node$\to$使用遥控UI控制机器人遍历环境$\to$调用save\_map.sh保存结果。关键SLAM参数包括:地图分辨率0.05m/像素、最大激光探测距离20m、触发扫描匹配的最小移动距离0.3m。建图完成后生成PGM灰度地图、YAML元数据文件和SLAM序列化文件。

\subsubsection{遥控UI与项目脚本}

本项目开发了基于Tkinter的图形化遥控界面(\texttt{teleop\_ui.py}),支持键盘(WASD+空格)和按钮两种控制方式。技术特点包括:多话题发布(同时向\texttt{/cmd\_vel}、\texttt{/mobile\_base\_controller/cmd\_vel\_unstamped}和\texttt{/model/tiago/cmd\_vel}发布,确保兼容不同配置)、以100ms间隔持续发送速度指令、渐进式速度调节(每次$\pm$0.1 m/s)以及实时状态显示。

\begin{figure}[H]
\centering
\includegraphics[width=0.4\textwidth]{photo/teleop_ui.png}
\caption{TIAGo遥控UI界面}
\end{figure}

项目在\texttt{map/}目录下提供六个Shell脚本,分为基础仿真、导航运行和自动化测试三类。

\paragraph{基础仿真与建图脚本}

\textbf{launch\_tiago.sh}是基础仿真启动脚本,一键启动Gazebo仿真环境、加载TIAGo模型、启动ROS-Gazebo话题桥接和遥控UI。支持通过环境变量配置世界名称、无头模式和机器人初始位姿。\textbf{launch\_tiago\_slam.sh}在基础仿真之上增加Robot State Publisher、SLAM Toolbox节点和RViz可视化,用于建图。\textbf{save\_map.sh}将SLAM建图结果保存为标准导航地图(PGM+YAML)、PNG格式和SLAM序列化文件。

\paragraph{导航与自动化测试脚本}

\textbf{launch\_tiago\_nav2.sh}在已保存的地图上启动完整Nav2导航堆栈,包括Gazebo仿真、话题桥接、TF发布、Nav2各服务节点和RViz可视化。支持通过环境变量指定地图文件(MAP\_FILE)、Nav2参数(NAV2\_PARAMS)和机械臂类型(ARM\_TYPE)等。

\textbf{launch\_tiago\_test.sh}是单次导航性能测试脚本,在Nav2环境基础上集成自动化测试流程:自动设置初始位姿、依次导航到预设waypoints、记录每段导航的时间/距离/误差等性能数据,最终输出YAML和CSV格式的测试报告。核心特性包括:支持参数文件增量合并(基础参数+参数覆盖+控制器覆盖)、每个waypoint独立超时控制(WAYPOINT\_TIMEOUT)、自动初始位姿设置(AUTO\_INIT\_POSE)。

\textbf{batch\_nav\_test.sh}是批量测试调度脚本,自动遍历多组参数配置和控制器组合,依次调用launch\_tiago\_test.sh执行测试。支持三种测试模式:仅测试参数配置、仅测试控制器、参数与控制器组合测试。具备断点续测(SKIP\_EXISTING)、测试间隔控制(PAUSE\_BETWEEN)、信号捕获清理等容错机制。测试结果按批次组织,自动生成batch\_summary.yaml汇总文件。

\begin{table}[H]
\centering
\caption{项目脚本功能概览}
\begin{tabular}{lp{10cm}}
\toprule
\textbf{脚本} & \textbf{功能} \\
\midrule
launch\_tiago.sh & 基础仿真:Gazebo + TIAGo + 话题桥接 + 遥控UI \\
launch\_tiago\_slam.sh & SLAM建图:基础仿真 + SLAM Toolbox + RViz \\
save\_map.sh & 保存SLAM地图为PGM/YAML/PNG格式 \\
launch\_tiago\_nav2.sh & Nav2导航:完整导航堆栈 + 可视化 \\
launch\_tiago\_test.sh & 单次测试:自动waypoint导航 + 性能数据采集 \\
batch\_nav\_test.sh & 批量测试:多配置/控制器遍历 + 结果汇总 \\
\bottomrule
\end{tabular}
\end{table}

%--------------------------------------------------------------------
\subsection{系统整体架构}

整个仓库管理员系统由多个相互协作的组件构成,通过ROS 2的话题(Topic)、服务(Service)和动作(Action)机制进行通信。

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.2cm,
    box/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=0.7cm, align=center, font=\small},
    bigbox/.style={rectangle, draw, rounded corners, minimum width=3cm, minimum height=0.8cm, align=center, fill=blue!15, font=\small\bfseries},
    arrow/.style={->, >=stealth, thick}
]
    % Gazebo层
    \node[bigbox, fill=orange!20] (gazebo) at (0,4) {Gazebo Sim};
    \node[box, fill=orange!10] (world) at (-2.5,2.8) {Warehouse\\World};
    \node[box, fill=orange!10] (tiago_sim) at (0,2.8) {TIAGo\\Model};
    \node[box, fill=orange!10] (sensors) at (2.5,2.8) {Sensors\\(LiDAR等)};

    % Bridge
    \node[bigbox, fill=yellow!30] (bridge) at (0,1.2) {ros\_gz\_bridge};

    % ROS 2层
    \node[bigbox, fill=green!20] (ros2) at (0,-0.3) {ROS 2 Humble};

    % ROS 2组件
    \node[box, fill=green!10] (rsp) at (-4,-1.8) {Robot State\\Publisher};
    \node[box, fill=green!10] (tf) at (-1.5,-1.8) {TF2};
    \node[box, fill=green!10] (nav2) at (1.5,-1.8) {Nav2\\Stack};
    \node[box, fill=green!10] (slam) at (4,-1.8) {SLAM\\Toolbox};

    % 用户接口
    \node[box, fill=purple!15] (rviz) at (-2.5,-3.5) {RViz2};
    \node[box, fill=purple!15] (teleop) at (0,-3.5) {Teleop\\UI};
    \node[box, fill=purple!15] (waypoint) at (2.5,-3.5) {Waypoint\\Follower};

    % 连接线
    \draw[arrow] (gazebo) -- (world);
    \draw[arrow] (gazebo) -- (tiago_sim);
    \draw[arrow] (gazebo) -- (sensors);
    \draw[arrow] (world) -- (bridge);
    \draw[arrow] (tiago_sim) -- (bridge);
    \draw[arrow] (sensors) -- (bridge);
    \draw[arrow] (bridge) -- (ros2);
    \draw[arrow] (ros2) -- (rsp);
    \draw[arrow] (ros2) -- (tf);
    \draw[arrow] (ros2) -- (nav2);
    \draw[arrow] (ros2) -- (slam);
    \draw[arrow] (rsp) -- (rviz);
    \draw[arrow] (nav2) -- (rviz);
    \draw[arrow] (slam) -- (rviz);
    \draw[arrow] (teleop) -- (ros2);
    \draw[arrow] (waypoint) -- (nav2);
\end{tikzpicture}
\caption{系统整体架构图}
\end{figure}

\subsubsection{仿真与通信层}

\textbf{Gazebo Sim}作为物理仿真引擎,承担世界仿真(加载warehouse.sdf定义的仓库环境)、机器人仿真(加载TIAGo的SDF模型并模拟其物理特性)、传感器仿真(模拟激光雷达扫描)和运动仿真(根据速度指令计算机器人轨迹)等职责。Gazebo内部使用ignition.msgs消息系统,与ROS 2不同,因此需要桥接。

\textbf{ros\_gz\_bridge}是连接Gazebo和ROS 2的关键组件,负责双向消息转换。主要桥接话题包括:/clock(仿真时间同步,Gz$\to$ROS)、/cmd\_vel(速度控制,ROS$\to$Gz)、/odom(里程计,Gz$\to$ROS)、/scan(激光扫描,Gz$\to$ROS)、/tf(坐标变换,Gz$\to$ROS)和/joint\_states(关节状态,Gz$\to$ROS)。桥接配置中,\texttt{[}表示Gazebo到ROS的单向桥接,\texttt{]}表示ROS到Gazebo的单向桥接。

\subsubsection{ROS 2通信机制与TF系统}

系统中各节点通过三种ROS 2通信机制协作:\textbf{话题通信}用于持续数据流传输,如激光扫描(10-20Hz)、里程计(50Hz)、速度指令(20Hz)、栅格地图(按需更新)和坐标变换(高频更新);\textbf{服务通信}用于请求-响应模式,如加载地图、保存SLAM地图和清除代价地图;\textbf{动作通信}用于长时间运行的任务,如导航到目标点、跟随路径点序列和计算路径。

\textbf{TF2}负责维护各坐标系之间的变换关系,是导航系统的核心。变换链为:map$\xrightarrow{\text{AMCL}}$odom$\xrightarrow{\text{odom\_to\_tf.py}}$base\_footprint$\xrightarrow{\text{robot\_state\_publisher}}$base\_link$\to$base\_laser\_link等。其中map$\to$odom变换由AMCL根据定位结果发布以校正里程计漂移,odom$\to$base\_footprint由odom\_to\_tf.py从/odom话题提取并发布,base\_footprint到其他坐标系由robot\_state\_publisher根据URDF发布。

\subsubsection{Nav2导航数据流与系统启动}

Nav2导航过程中的数据流向为:感知输入(激光扫描$\to$代价地图更新,TF变换$\to$机器人位姿获取)$\to$定位(AMCL接收激光和地图,输出map$\to$odom变换)$\to$路径规划(Planner Server接收目标点和全局代价地图,输出全局路径)$\to$路径跟踪(Controller Server接收全局路径和局部代价地图,输出速度指令)$\to$执行(速度指令通过Bridge传递给Gazebo,Gazebo更新机器人位姿,新的传感器数据反馈回ROS 2)。

\textbf{RViz2}作为可视化工具,订阅/map、/scan、/tf、/plan、/local\_plan和代价地图等数据进行显示,同时提供2D Pose Estimate(设置初始位姿)和2D Goal Pose(设置导航目标)交互功能。

为确保系统正常运行,各组件需按顺序启动:Gazebo仿真$\to$ros\_gz\_bridge$\to$robot\_state\_publisher$\to$静态TF/odom\_to\_tf$\to$SLAM或Map Server$\to$Nav2 Stack$\to$RViz$\to$Teleop UI。这个启动顺序在launch\_tiago\_nav2.sh脚本中已正确实现。

\newpage
%====================================================================
% 第二部分:Nav2导航参数优化
%====================================================================
\section{Nav2导航参数优化}

本部分介绍Nav2导航参数优化的实验设计、测试框架、参数配置以及实验结果分析。

%--------------------------------------------------------------------
\subsection{实验设计与测试框架}

\subsubsection{实验方法与测试路线}

为科学评估不同Nav2参数配置对导航性能的影响,本项目采用\textbf{控制变量法}进行实验设计:设计一条固定的测试路线,在相同的仿真环境和初始条件下,仅改变待测试的参数配置,从而获得可对比的性能数据。这种设计确保了公平性(消除路径差异影响)、可重复性(便于验证结果一致性)和可对比性(支持定量比较)。

测试路线通过自主开发的\texttt{record\_waypoints.py}工具获取,支持在RViz中点击地图捕获目标点或按"r"键记录机器人当前位置两种方式。经过多次调整验证,最终确定了包含\textbf{12个目标点}的测试路线,覆盖仓库的货架通道、开阔区域和角落位置。路线设计遵循以下原则:覆盖直线、转弯、狭窄通道等典型场景;包含不同难度路段;目标朝向多样化(-163.5°至115.2°);最后一点接近起点形成闭环。

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{photo/waypoints_visualization.png}
\caption{测试路线可视化:绿色方块为起点,红色星形为终点,蓝色虚线表示导航顺序}
\label{fig:test_route}
\end{figure}

\subsubsection{评价指标体系}

为全面评估导航性能,本项目通过\texttt{nav\_performance\_test.py}采集以下指标:

\textbf{单段导航指标}(每个waypoint):导航是否成功(success)、导航耗时(time\_seconds)、实际行驶距离(distance\_meters,通过里程计累积计算)、位置误差(position\_error,到达位置与目标位置的欧氏距离)、朝向误差(yaw\_error,到达朝向与目标朝向的角度差)。

\textbf{整体性能指标}:成功率(success\_rate,成功到达的waypoint占比)、总耗时(total\_time,所有成功导航的累计时间)、总距离(total\_distance,所有成功导航的累计里程)、平均速度(avg\_velocity,总距离除以总耗时)、平均位置误差(avg\_position\_error)、最大位置误差(max\_position\_error)、平均朝向误差(avg\_yaw\_error)。

这些指标从效率(时间、速度)、可靠性(成功率)和精度(位置/朝向误差)三个维度全面刻画导航性能,其中成功率是最关键的指标——导航失败意味着任务无法完成,其他指标仅在成功的前提下才有意义。

\subsubsection{自动化测试框架}

为系统性评估不同参数配置,本项目实现了自动化批量测试框架,由调度层(\texttt{batch\_nav\_test.sh})和执行层(\texttt{launch\_tiago\_test.sh})组成。

测试框架采用\textbf{增量覆盖}机制管理参数:各配置文件存放在\texttt{config/nav2\_params/}目录下,只需指定与基准不同的参数,系统通过\texttt{merge\_nav2\_params.py}自动合并生成完整配置。单次测试流程为:启动Gazebo仿真$\to$生成TIAGo机器人$\to$启动Nav2导航堆栈$\to$自动设置初始位姿$\to$依次执行waypoint导航$\to$采集性能数据$\to$输出YAML和CSV格式报告。主要控制参数包括WAYPOINT\_TIMEOUT(单点超时,默认120秒)、HEADLESS(无头模式)、SKIP\_EXISTING(断点续测)。

框架通过信号捕获(trap)确保中断时正确清理所有进程,测试状态实时记录到\texttt{batch\_summary.yaml},单次失败不会中断批量测试。测试结果按批次组织,每批次生成独立目录,包含批量摘要和各配置的详细结果文件。

%--------------------------------------------------------------------
\subsection{参数配置与理论分析}

\subsubsection{测试配置设计}

本项目设计了6组参数配置,每组配置涉及控制器、代价地图、行为服务器等多个模块的参数协调调整。

\textbf{baseline}(基准配置):采用中等速度(0.5 m/s)和标准安全边距,各参数平衡设置。DWB控制器仿真时间1.2s,路径对齐权重(PathAlign/PathDist)与目标对齐权重(GoalAlign/GoalDist)分别为32和24,障碍物权重0.03。RotateToGoal权重48,减速因子3.0。代价地图膨胀半径0.55m,衰减因子3.0。作为对照基准验证其他配置的改进效果。

\textbf{better\_rotation}(优化转向):针对原始配置转向迟缓的问题进行优化。提高最小转向速度(min\_speed\_theta: 0.3)避免缓慢转向,增加角速度采样数(vtheta\_samples: 25)获得更细腻的转向选择,提高RotateToGoal权重(48)并启用前瞻转向(lookahead\_time: 1.0)实现提前转向。同时提高角加速度限制(3.5 rad/s²)加快转向响应。最大速度提升至0.6 m/s。

\textbf{high\_speed}(高速配置):追求最快导航速度,适合开阔环境。最大线速度提升至0.8 m/s,角速度1.5 rad/s,加速度2.5 m/s²。缩短仿真时间(0.8s)加快决策,减小膨胀半径(全局0.50m,局部0.45m)允许更激进的路径,扩大局部代价地图(4m×4m)适应高速感知需求。提高目标权重(GoalAlign/GoalDist: 28)加速到达。

\textbf{aggressive}(激进配置):追求快速响应,适合时间敏感场景。采用最高加速度(3.0 m/s²线性,4.5 rad/s²角度)实现快速启停,缩短进度检查时间(movement\_time\_allowance: 8.0s)要求快速进度。降低障碍物权重(BaseObstacle.scale: 0.015)减少避障导致的减速,显著提高目标权重(GoalAlign/GoalDist: 32)和RotateToGoal权重(52)强化目标导向,降低减速因子(2.0)加快转向。膨胀半径减至0.45m/0.40m。

\textbf{safe\_narrow}(安全狭窄通道):专为复杂狭窄环境设计。采用低速(0.35 m/s)和低加速度(1.5 m/s²)确保稳定,延长进度检查时间(15.0s)和放宽目标容差(0.30m)适应困难路段。显著提高障碍物权重(BaseObstacle.scale: 0.08)增强避障,减小膨胀半径(0.45m/0.40m)允许通过狭窄区域,降低衰减因子(2.5)保持警惕。延长仿真时间(1.5s)实现更谨慎的规划。

\textbf{smooth\_path}(平滑路径):追求平稳运动,适合对舒适性要求高的场景。采用最低加速度(1.2 m/s²线性,2.0 rad/s²角度)实现平滑启停,延长仿真时间(2.0s)规划更平滑轨迹。提高路径对齐权重(PathAlign/PathDist: 40)加强路径跟随,提高RotateToGoal减速因子(5.0)和前瞻时间(1.5s)实现平滑转向。收紧目标容差(0.20m)提高到达精度。扩大局部地图(4m×4m)获得更平滑规划。

\begin{table}[H]
\centering
\caption{各配置核心参数对比}
\begin{tabular}{lcccccc}
\toprule
\textbf{参数} & \textbf{baseline} & \textbf{better\_rot} & \textbf{high\_speed} & \textbf{aggressive} & \textbf{safe\_narrow} & \textbf{smooth} \\
\midrule
max\_vel\_x (m/s) & 0.5 & 0.6 & 0.8 & 0.7 & 0.35 & 0.5 \\
max\_vel\_theta (rad/s) & 1.0 & 1.2 & 1.5 & 1.4 & 0.8 & 0.9 \\
acc\_lim\_x (m/s²) & 2.0 & 2.0 & 2.5 & 3.0 & 1.5 & 1.2 \\
acc\_lim\_theta (rad/s²) & 3.2 & 3.5 & 4.0 & 4.5 & 2.5 & 2.0 \\
sim\_time (s) & 1.2 & 1.0 & 0.8 & 0.8 & 1.5 & 2.0 \\
vtheta\_samples & 20 & 25 & 25 & 25 & 20 & 25 \\
PathAlign.scale & 32 & 32 & 32 & 28 & 32 & 40 \\
GoalDist.scale & 24 & 24 & 28 & 32 & 20 & 20 \\
BaseObstacle.scale & 0.03 & 0.02 & 0.02 & 0.015 & 0.08 & 0.03 \\
RotateToGoal.scale & 48 & 48 & 48 & 52 & 48 & 48 \\
slowing\_factor & 3.0 & 3.0 & 2.5 & 2.0 & 4.0 & 5.0 \\
inflation\_radius (m) & 0.55 & 0.55 & 0.50 & 0.45 & 0.45 & 0.55 \\
xy\_goal\_tolerance (m) & 0.25 & 0.25 & 0.25 & 0.25 & 0.30 & 0.20 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{参数影响机理}

\textbf{速度与加速度参数}:max\_vel\_x和max\_vel\_theta直接决定导航效率上限,但高速需要配合足够的感知范围(局部代价地图尺寸)和决策时间(sim\_time)。加速度参数影响响应速度和运动平滑度——aggressive的高加速度(3.0 m/s²)实现快速响应但可能产生抖动,smooth\_path的低加速度(1.2 m/s²)运动平稳但启停耗时增加。

\textbf{轨迹仿真与采样参数}:sim\_time决定DWB控制器预测轨迹的时间窗口,较长的仿真时间(smooth\_path: 2.0s)能规划更平滑路径但响应变慢,较短的仿真时间(high\_speed: 0.8s)响应快但可能产生短视行为。vtheta\_samples增加(25 vs 20)可获得更细腻的转向控制,对转向优化配置尤为重要。

\textbf{评价函数权重}:DWB通过多个Critics评分选择最优轨迹。PathAlign/PathDist控制路径跟随紧密度,smooth\_path设为40强化路径跟随;GoalAlign/GoalDist控制目标导向性,aggressive设为32加速到达;BaseObstacle控制避障倾向,safe\_narrow设为0.08显著增强避障。RotateToGoal.scale和slowing\_factor共同影响转向行为——高scale使机器人更倾向转向目标,高slowing\_factor使转向更平滑但较慢。

\textbf{代价地图参数}:inflation\_radius决定机器人与障碍物的安全距离,aggressive和safe\_narrow采用较小值(0.45m)以通过狭窄通道,但aggressive因高速可能有碰撞风险。cost\_scaling\_factor控制代价衰减速度,较高值使代价快速衰减允许更靠近障碍物。局部地图尺寸影响感知范围,高速配置扩大至4m×4m以适应更远的前瞻需求。

%--------------------------------------------------------------------
\subsection{实验结果与分析}

\subsubsection{总体性能对比}

在12个目标点的测试路线上,各配置的导航性能如下表所示。

\begin{table}[H]
\centering
\caption{导航性能总体对比}
\begin{tabular}{lcccccc}
\toprule
\textbf{配置} & \textbf{成功率(\%)}  & \textbf{总时间(s)} & \textbf{总距离(m)} & \textbf{平均速度(m/s)} & \textbf{位置误差(m)} & \textbf{朝向误差(°)} \\
\midrule
baseline & \textbf{100.0} & 548.2 & 248.4 & 0.453 & 0.234 & 17.2 \\
better\_rotation & \textbf{100.0} & 562.6 & 251.5 & 0.447 & 0.213 & 19.1 \\
smooth\_path & \textbf{100.0} & 573.0 & 249.1 & 0.435 & 0.213 & \textbf{14.4} \\
safe\_narrow & 91.7 & 742.1 & 204.0 & 0.275 & 0.287 & 20.7 \\
aggressive & 75.0 & 541.9 & 193.5 & 0.357 & \textbf{0.177} & 20.2 \\
high\_speed & 8.3 & 331.5 & 10.1 & 0.030 & 0.059 & 23.6 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{结果分析与关键发现}

\textbf{成功率分析}:baseline、better\_rotation和smooth\_path均达到100\%成功率,证明中等速度配合适当参数调优是最稳定的选择。safe\_narrow(91.7\%)在point\_5超时失败——虽设计为安全配置,但过低速度(0.35 m/s)导致长距离路段无法按时到达。aggressive(75\%)失败3个点,高加速度和小膨胀半径导致复杂区域控制不稳定。high\_speed(8.3\%)几乎全部失败,仅完成第一个点,过高速度(0.8 m/s)和过短仿真时间(0.8s)导致控制器无法稳定跟踪路径。

\textbf{效率与精度分析}:在完成全部12点的配置中,baseline最快(548.2s,平均0.453 m/s),better\_rotation次之(562.6s),smooth\_path最慢(573.0s)但朝向精度最优(14.4°)。其长仿真时间(2.0s)和高RotateToGoal减速因子使转向更精确。位置精度各配置相近(0.21-0.29m),均在目标容差附近。

\textbf{关键发现}:(1) 速度并非越快越好——high\_speed设置最高速度却因控制不稳定几乎全部失败,实际有效速度反而最低;(2) 参数需要协调配合——单独提高速度而不调整仿真时间、采样数等参数会导致系统不稳定,baseline的成功在于各参数平衡;(3) sim\_time是关键参数——过短(0.8s)导致控制器"短视"无法有效规划,过长(2.0s)虽路径更优但响应变慢,1.0-1.2s是较好平衡点;(4) 安全与效率需权衡——safe\_narrow过于保守反而导致超时失败;(5) 转向优化效果显著——better\_rotation通过提高min\_speed\_theta和RotateToGoal权重使转向更果断。

\subsubsection{配置推荐}

基于实验结果,针对不同场景推荐:通用场景使用baseline(平衡的速度与稳定性,100\%成功率);精确停靠使用smooth\_path(最小朝向误差14.4°,平滑运动);快速响应使用better\_rotation(转向果断,效率略优于baseline);狭窄通道建议在safe\_narrow基础上适当提高速度以避免超时。

\section{控制器对比分析}

本部分对Nav2支持的三种主流控制器(DWB、RPP、MPPI)以及自主开发的Stanley控制器进行对比测试与分析。

%--------------------------------------------------------------------
\subsection{控制器算法原理}

Nav2框架通过Controller Server提供可插拔的控制器接口,允许用户根据应用场景选择或开发合适的路径跟踪算法。本项目测试了四种控制器,各有不同的算法原理和适用场景。

\subsubsection{DWB控制器(Dynamic Window Approach)}

DWB控制器基于动态窗口法,是Nav2的默认控制器。其核心思想是在速度空间$(v, \omega)$中采样多条候选轨迹,通过多个评价函数(Critics)对每条轨迹评分,选择得分最高的轨迹对应的速度指令执行。主要参数包括:仿真时间sim\_time(决定轨迹预测长度)、采样数量vx/vtheta\_samples(影响搜索精度)、以及PathAlign、GoalDist、BaseObstacle等评分权重(控制行为偏好)。DWB的优势在于通用性强、参数可调性高,适合大多数场景;缺点是计算量随采样数增加而增长。

\subsubsection{RPP控制器(Regulated Pure Pursuit)}

RPP控制器是对经典纯追踪(Pure Pursuit)算法的改进。纯追踪算法通过在路径前方选取一个lookahead点,计算机器人转向该点所需的曲率来生成转向指令。RPP在此基础上增加了三种速度调节机制:根据路径曲率调节(弯道减速)、根据障碍物距离调节(靠近障碍物减速)、根据目标点距离调节(接近目标减速)。关键参数包括lookahead\_dist(前瞻距离,影响路径跟踪平滑度)、desired\_linear\_vel(期望速度)、rotate\_to\_heading\_angular\_vel(原地转向角速度)。RPP的优势在于计算量小、响应快速,适合开阔环境和高速行驶;缺点是在复杂狭窄环境中表现不如DWB。

\subsubsection{MPPI控制器(Model Predictive Path Integral)}

MPPI控制器基于模型预测控制(MPC)和路径积分理论,是四种控制器中最复杂的。其工作原理为:首先根据运动模型预测大量(batch\_size,本配置为2000条)带噪声的候选轨迹,然后使用多个Critics计算每条轨迹的代价,最后通过指数加权平均得到最优控制输入。MPPI使用的Critics包括:ConstraintCritic(约束满足)、ObstaclesCritic(障碍物避免)、GoalCritic(目标接近)、PathAlignCritic(路径对齐)、PreferForwardCritic(前进偏好)等。主要参数包括time\_steps(预测步数,本配置56步)、model\_dt(时间步长0.05s)、temperature(控制探索程度)。MPPI的优势在于轨迹质量高、避障能力强;缺点是计算量大,建议使用GPU加速。

\subsubsection{Stanley控制器(自定义实现)}

Stanley控制器最初由斯坦福大学开发用于DARPA无人驾驶挑战赛,是一种基于横向误差的路径跟踪算法。与纯追踪不同,Stanley控制器同时考虑航向误差(heading error)和横向偏差(cross-track error),转向角计算公式为:
\begin{equation}
\delta = \theta_e + \arctan\left(\frac{k \cdot e_{ct}}{v + v_{soft}}\right)
\end{equation}
其中$\theta_e$为航向误差(机器人朝向与路径切线方向的夹角),$e_{ct}$为横向偏差(机器人到路径的垂直距离),$k$为增益系数,$v$为当前速度,$v_{soft}$为软化速度(防止低速时分母过小)。这种设计使得机器人在偏离路径时能够同时修正航向和位置。

%--------------------------------------------------------------------
\subsection{Stanley控制器插件开发}

本项目基于nav2\_core::Controller接口开发了Stanley控制器插件,实现了完整的Nav2集成。

\subsubsection{插件架构与接口实现}

Nav2控制器插件需要继承\texttt{nav2\_core::Controller}基类并实现以下核心方法:

\textbf{configure()}:初始化控制器,获取节点句柄、TF缓冲区和代价地图,并从参数服务器加载配置参数。本实现声明并获取k\_gain(横向误差增益)、softening\_speed(软化速度)、max\_steer\_rad(最大转向角)、lookahead\_dist(前瞻距离)等10个参数。

\textbf{setPlan()}:接收全局路径规划器生成的路径,存储到成员变量供后续使用。使用互斥锁保护路径访问以确保线程安全。

\textbf{computeVelocityCommands()}:核心控制逻辑,根据当前位姿和速度计算下一时刻的速度指令。实现流程为:首先检查是否到达目标(位置误差<goal\_tolerance\_lin且朝向误差<goal\_tolerance\_yaw),若到达则返回零速度;否则在路径上寻找前瞻点,计算航向误差和横向偏差,应用Stanley公式得到转向角,最后根据转向角大小调节线速度(转向越大速度越低)。

\textbf{setSpeedLimit()}:支持外部速度限制接口,可以是绝对值或相对比例。

\subsubsection{核心算法实现}

控制器的核心计算在\texttt{computeVelocityCommands()}中实现。首先通过\texttt{findTargetPoint()}在路径上搜索第一个距离机器人超过lookahead\_dist的点作为目标点;然后计算路径在该点附近的切线方向(通过相邻两点连线确定);接着计算横向偏差$e_{ct}$——使用向量叉积确定机器人相对路径的左右偏移及其符号;最后应用Stanley公式计算转向角并限幅。线速度采用指数衰减策略:$v = v_{max} \cdot e^{-k_{slow} \cdot |\delta|}$,即转向角越大速度越低,确保弯道安全。接近目标时额外降低速度并增强转向以精确停靠。

\subsubsection{插件注册与编译}

控制器通过pluginlib机制注册为Nav2插件。plugin.xml定义插件元信息:
\begin{lstlisting}[language=XML]
<library path="stanley_controller">
  <class type="custom_controller::StanleyController"
         base_class_type="nav2_core::Controller">
    <description>Stanley-based path follower</description>
  </class>
</library>
\end{lstlisting}

CMakeLists.txt配置编译规则,使用ament\_cmake构建系统,链接nav2\_core、pluginlib、tf2等依赖库,最终生成libstanley\_controller.so共享库。编译安装后,可在Nav2参数文件中通过\texttt{plugin: "custom\_controller::StanleyController"}指定使用该控制器。

\subsubsection{关键参数说明与设计决策}

Stanley控制器共有10个可配置参数,分为控制算法参数、速度限制参数和目标判定参数三类。

\begin{table}[H]
\centering
\caption{Stanley控制器参数详解}
\begin{tabular}{llcp{6cm}}
\toprule
\textbf{参数名} & \textbf{类型} & \textbf{默认值} & \textbf{说明} \\
\midrule
\multicolumn{4}{l}{\textit{控制算法参数}} \\
k\_gain & double & 1.8 & 横向误差增益,控制对路径偏离的响应强度 \\
softening\_speed & double & 0.1 & 软化速度(m/s),防止低速时除零 \\
max\_steer\_rad & double & 0.7 & 最大转向角(rad),约40° \\
lookahead\_dist & double & 0.7 & 前瞻距离(m),寻找目标点的距离阈值 \\
slow\_down\_gain & double & 2.5 & 减速增益,控制转向时的速度衰减程度 \\
\midrule
\multicolumn{4}{l}{\textit{速度限制参数}} \\
max\_linear\_speed & double & 0.35 & 最大线速度(m/s) \\
min\_linear\_speed & double & 0.05 & 最小线速度(m/s),防止完全停止 \\
max\_angular\_speed & double & 1.0 & 最大角速度(rad/s) \\
\midrule
\multicolumn{4}{l}{\textit{目标判定参数}} \\
goal\_tolerance\_lin & double & 0.05 & 位置容差(m),判定到达目标的距离阈值 \\
goal\_tolerance\_yaw & double & 0.08 & 朝向容差(rad),约4.6° \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{控制算法参数设计决策}

\textbf{k\_gain(横向误差增益)}:该参数决定了Stanley公式中横向误差项的权重。根据Stanley原始论文,增益值通常在1.0-3.0之间。本实现选择1.8的原因是:(1) 过小的增益(如0.5)会导致路径跟踪不紧密,机器人偏离路径后收敛缓慢;(2) 过大的增益(如5.0)在差速驱动机器人上容易引发振荡,因为差速底盘的转向响应与Ackermann模型不同;(3) 1.8在仿真测试中表现出较好的跟踪精度与稳定性平衡。

\textbf{softening\_speed(软化速度)}:Stanley公式包含$v + v_{soft}$作为分母,当机器人速度接近零时,若无软化项会导致转向角趋于无穷大。设置0.1 m/s的软化速度确保:(1) 静止启动时不会产生剧烈转向;(2) 低速精确停靠时控制平稳。该值应略大于min\_linear\_speed以确保有效性。

\textbf{lookahead\_dist(前瞻距离)}:前瞻距离决定了控制器"看多远"来确定目标点。设置0.7m的考量:(1) 过短(如0.2m)会导致控制器过于"近视",在弯道处反应滞后;(2) 过长(如2.0m)会使控制器忽略近处的路径细节,切弯过大;(3) 0.7m约为机器人直径的2.5倍,在仓库通道环境中提供足够的前瞻同时保持路径跟踪精度。

\textbf{slow\_down\_gain(减速增益)}:线速度通过$v = v_{max} \cdot e^{-k_{slow} \cdot |\delta|}$计算,该参数控制转向角对速度的影响程度。设置2.5意味着:(1) 转向角为0.4rad($\approx$23°)时,速度降至最大值的37\%;(2) 转向角为0.7rad(最大)时,速度降至最大值的17\%;(3) 这种指数衰减策略确保弯道安全同时避免不必要的减速。

\paragraph{速度限制参数设计决策}

\textbf{max\_linear\_speed}设为0.35 m/s,显著低于DWB的0.5 m/s。这是考虑到:(1) Stanley控制器设计用于精确对齐阶段,不需要高速;(2) 差速驱动底盘在高速下执行Stanley算法的转向角映射可能产生不稳定;(3) 较低速度有助于提高停靠精度。

\textbf{min\_linear\_speed}设为0.05 m/s,确保机器人始终保持微小前进,避免陷入纯转向状态。这对于差速驱动机器人尤为重要,因为Stanley算法假设车辆持续前进。

\paragraph{目标判定参数设计决策}

\textbf{goal\_tolerance\_lin}设为0.05m(5cm),远小于DWB的0.25m。这是精确停车场景的核心需求——在货架对接、充电桩停靠等应用中,5cm的精度通常是必要的。

\textbf{goal\_tolerance\_yaw}设为0.08rad(约4.6°),确保机器人停靠后朝向正确。对于需要后续操作(如机械臂抓取)的场景,正确的朝向与位置同样重要。

\paragraph{参数调优建议}

针对不同应用场景,建议调整以下参数:(1) \textbf{开阔环境}:可适当增大max\_linear\_speed至0.5m/s,减小k\_gain至1.2以获得更平滑的轨迹;(2) \textbf{狭窄通道}:增大k\_gain至2.5提高路径跟踪紧密度,减小lookahead\_dist至0.4m避免切弯;(3) \textbf{高精度停靠}:减小goal\_tolerance\_lin至0.03m,增大slow\_down\_gain至3.0确保低速接近。

%--------------------------------------------------------------------
\subsection{控制器对比测试}

\subsubsection{测试配置}

四种控制器均使用baseline参数配置,在相同的12点测试路线上进行评估。控制器特定参数配置如下:

\begin{table}[H]
\centering
\caption{控制器核心参数配置}
\begin{tabular}{lcccc}
\toprule
\textbf{参数类别} & \textbf{DWB} & \textbf{RPP} & \textbf{MPPI} & \textbf{Stanley} \\
\midrule
控制频率 (Hz) & 20 & 20 & 30 & 20 \\
最大线速度 (m/s) & 0.5 & 0.5 & 0.5 & 0.35 \\
最大角速度 (rad/s) & 1.0 & 1.8 & 1.9 & 1.0 \\
前瞻距离/仿真时间 & 1.7s & 0.6m & 56步×0.05s & 0.7m \\
采样/批次数 & 20×20 & - & 2000 & - \\
目标容差 (m) & 0.25 & 0.25 & 0.25 & 0.05 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{测试结果}

\begin{table}[H]
\centering
\caption{控制器性能对比}
\begin{tabular}{lcccccc}
\toprule
\textbf{控制器} & \textbf{成功率(\%)} & \textbf{总时间(s)} & \textbf{总距离(m)} & \textbf{平均速度(m/s)} & \textbf{位置误差(m)} & \textbf{朝向误差(°)} \\
\midrule
DWB & \textbf{100.0} & 554.1 & 248.8 & 0.449 & 0.255 & \textbf{16.9} \\
RPP & \textbf{100.0} & \textbf{535.4} & 248.2 & \textbf{0.464} & 0.252 & 18.6 \\
MPPI & \textbf{100.0} & 615.1 & 248.8 & 0.405 & \textbf{0.240} & 17.9 \\
Stanley & 8.3 & 1158.7 & 10.0 & 0.009 & 0.115* & 17.2* \\
\bottomrule
\end{tabular}
\\[0.5em]
\footnotesize{*Stanley仅成功1个点,误差数据不具统计意义}
\end{table}

\subsubsection{图表化分析}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    width=0.48\textwidth,
    height=5cm,
    ylabel={成功率 (\%)},
    symbolic x coords={DWB, RPP, MPPI, Stanley},
    xtick=data,
    ymin=0, ymax=120,
    bar width=20pt,
    nodes near coords,
    nodes near coords align={vertical},
    every node near coord/.append style={font=\small},
    title={成功率对比},
    title style={font=\bfseries},
]
\addplot[fill=blue!60] coordinates {(DWB,100) (RPP,100) (MPPI,100) (Stanley,8.3)};
\end{axis}
\end{tikzpicture}
\hfill
\begin{tikzpicture}
\begin{axis}[
    ybar,
    width=0.48\textwidth,
    height=5cm,
    ylabel={平均速度 (m/s)},
    symbolic x coords={DWB, RPP, MPPI, Stanley},
    xtick=data,
    ymin=0, ymax=0.55,
    bar width=20pt,
    nodes near coords,
    nodes near coords align={vertical},
    every node near coord/.append style={font=\small},
    title={导航效率对比},
    title style={font=\bfseries},
]
\addplot[fill=green!60] coordinates {(DWB,0.449) (RPP,0.464) (MPPI,0.405) (Stanley,0.009)};
\end{axis}
\end{tikzpicture}
\caption{控制器成功率与导航效率对比(Stanley因大量失败导致有效速度极低)}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    width=0.48\textwidth,
    height=5cm,
    ylabel={位置误差 (m)},
    symbolic x coords={DWB, RPP, MPPI},
    xtick=data,
    ymin=0, ymax=0.35,
    bar width=25pt,
    nodes near coords,
    nodes near coords align={vertical},
    every node near coord/.append style={font=\small},
    title={位置精度对比},
    title style={font=\bfseries},
]
\addplot[fill=orange!60] coordinates {(DWB,0.255) (RPP,0.252) (MPPI,0.240)};
\end{axis}
\end{tikzpicture}
\hfill
\begin{tikzpicture}
\begin{axis}[
    ybar,
    width=0.48\textwidth,
    height=5cm,
    ylabel={朝向误差 (°)},
    symbolic x coords={DWB, RPP, MPPI},
    xtick=data,
    ymin=0, ymax=25,
    bar width=25pt,
    nodes near coords,
    nodes near coords align={vertical},
    every node near coord/.append style={font=\small},
    title={朝向精度对比},
    title style={font=\bfseries},
]
\addplot[fill=red!60] coordinates {(DWB,16.9) (RPP,18.6) (MPPI,17.9)};
\end{axis}
\end{tikzpicture}
\caption{三种成功控制器的精度对比(Stanley数据因样本不足未纳入)}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    ybar,
    width=0.75\textwidth,
    height=6cm,
    ylabel={总导航时间 (s)},
    symbolic x coords={RPP, DWB, MPPI, Stanley},
    xtick=data,
    ymin=0, ymax=1300,
    bar width=30pt,
    nodes near coords,
    nodes near coords align={vertical},
    every node near coord/.append style={font=\small},
    title={导航耗时对比(含失败重试时间)},
    title style={font=\bfseries},
    xlabel={控制器(按耗时排序)},
]
\addplot[fill=purple!50] coordinates {(RPP,535.4) (DWB,554.1) (MPPI,615.1) (Stanley,1158.7)};
\end{axis}
\end{tikzpicture}
\caption{四种控制器总耗时对比:RPP最快,Stanley因多次超时导致总耗时最长}
\end{figure}

从图表可以直观看出:(1) DWB、RPP、MPPI三种Nav2原生控制器均达到100\%成功率,Stanley仅8.3\%;(2) RPP平均速度最高(0.464 m/s),MPPI最低(0.405 m/s);(3) 位置精度MPPI最优(0.240m),朝向精度DWB最优(16.9°);(4) 总耗时RPP最短(535.4s),Stanley因大量超时导致总耗时超过1150秒。

\subsubsection{结果分析}

\textbf{成功率分析}:DWB、RPP和MPPI三种Nav2原生控制器均达到100\%成功率,表现稳定可靠。自定义的Stanley控制器仅完成12个目标点中的1个(8.3\%成功率),其余11个均超时失败。分析失败原因:Stanley控制器设计用于车辆模型(Ackermann转向),其假设前轮可以独立转向,但TIAGo采用差速驱动底盘,只能通过左右轮差速实现转向。虽然本实现将转向角映射为角速度指令,但在需要大角度转向的场景(如狭窄通道调头)表现不佳,容易陷入振荡或无法及时转向导致超时。

\textbf{效率分析}:在三个成功的控制器中,RPP最快(535.4s,平均0.464 m/s),DWB次之(554.1s,0.449 m/s),MPPI最慢(615.1s,0.405 m/s)。RPP的高效率源于其简单的几何计算和较高的目标速度设置;MPPI较慢的原因是其控制频率虽高(30Hz)但每次决策需要评估2000条轨迹,计算开销大,导致实际控制响应略有延迟。

\textbf{精度分析}:位置精度方面,MPPI最优(0.240m),略优于RPP(0.252m)和DWB(0.255m);朝向精度方面,DWB最优(16.9°),优于MPPI(17.9°)和RPP(18.6°)。MPPI通过大量轨迹采样能够找到更优的到达路径,位置精度最高;DWB的RotateToGoal评分函数专门优化到达朝向,因此朝向精度最好;RPP采用rotate\_to\_heading策略在到达前进行原地转向调整,可能因时间不足导致朝向误差略大。

\subsubsection{控制器选型建议}

基于测试结果,针对不同应用场景推荐如下:

\textbf{通用场景}:推荐DWB控制器。作为Nav2默认控制器,DWB在效率和精度间取得良好平衡,参数可调性强,适合大多数室内导航任务。

\textbf{追求效率}:推荐RPP控制器。RPP计算量最小,响应最快,适合开阔环境、对实时性要求高或计算资源受限的场景。

\textbf{追求精度}:推荐MPPI控制器。MPPI通过大规模采样获得最优轨迹,位置精度最高,适合对停靠精度要求严格的场景,但需要较强的计算能力。

\textbf{Stanley控制器}:当前实现不适合差速驱动机器人,需要进一步优化以适配TIAGo的运动学模型,或改用专为差速驱动设计的控制算法。

\section{行为树子任务设计}

本部分介绍Nav2行为树的基本原理,以及本项目设计的动态多控制器行为树方案。该行为树的核心特点是\textbf{集成不少于三种控制器,并具备控制器ID的动态切换能力}。

%--------------------------------------------------------------------
\subsection{行为树基础}

\subsubsection{行为树概述}

行为树(Behavior Tree, BT)是一种用于控制决策流程的树状结构,最初在游戏AI中广泛应用,近年来被引入机器人领域。与传统有限状态机(FSM)相比,行为树具有模块化程度高、可复用性强、易于调试和扩展等优势。Nav2采用BehaviorTree.CPP库实现行为树,通过XML文件定义导航任务的执行流程。

行为树由多种类型的节点组成,每个节点执行后返回三种状态之一:SUCCESS(成功)、FAILURE(失败)或RUNNING(运行中)。主要节点类型包括:

\textbf{控制节点(Control Nodes)}:决定子节点的执行顺序和逻辑。\texttt{Sequence}(序列节点)按顺序执行子节点,任一子节点失败则整体失败,全部成功才返回成功——适合表达"依次完成A、B、C"的逻辑。\texttt{Fallback}(回退节点,又称Selector)依次尝试子节点直到某个成功,全部失败才返回失败——适合表达"尝试A,不行就试B"的容错逻辑。

\textbf{动作节点(Action Nodes)}:执行具体操作并返回结果。Nav2提供丰富的动作节点,如\texttt{ComputePathToPose}(计算路径)、\texttt{FollowPath}(跟随路径)、\texttt{BackUp}(后退)、\texttt{Wait}(等待)、\texttt{ClearEntireCostmap}(清除代价地图)等。其中\texttt{FollowPath}节点支持通过\texttt{controller\_id}参数指定使用的控制器,这是实现动态控制器切换的基础。

\textbf{条件节点(Condition Nodes)}:检查某个条件是否满足。如\texttt{GoalReached}检查是否到达目标,是精确停车判断的关键节点。

\textbf{装饰节点(Decorator Nodes)}:修饰单个子节点的行为。\texttt{SpeedController}限制导航速度,通过min\_rate和max\_rate参数控制速度范围,是实现分阶段减速的核心节点。

\subsubsection{Blackboard与动态参数传递}

Blackboard(黑板)是行为树的共享数据存储机制,允许节点之间传递数据。通过\texttt{SetBlackboard}节点可以在运行时修改黑板变量,而其他节点可以通过\texttt{\{variable\_name\}}语法引用这些变量。这种机制使得\textbf{同一个FollowPath节点可以在不同阶段调用不同的控制器}——只需在执行前通过SetBlackboard修改controller\_id变量即可。

%--------------------------------------------------------------------
\subsection{动态多控制器行为树设计}

本项目设计的\texttt{dynamic\_multi\_controller.xml}行为树实现了精确停车功能,其核心特点是\textbf{集成三种不同的控制器,并通过Blackboard机制在运行时动态切换控制器ID},充分发挥各控制器在不同阶段的优势。

\subsubsection{三种控制器配置}

行为树使用的三种控制器需要在Nav2参数文件中预先配置:

\begin{table}[H]
\centering
\caption{动态多控制器行为树使用的三种控制器}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{控制器ID} & \textbf{控制器类型} & \textbf{特点与用途} \\
\midrule
FollowPath & DWB(快速配置) & 高速响应,max\_vel\_x=0.5m/s,用于快速接近阶段 \\
SlowFollowPath & DWB(慢速配置) & 平稳跟踪,max\_vel\_x=0.3m/s,用于缓行接近阶段 \\
StanleyFollowPath & 自定义Stanley & 横向误差校正,max\_vel\_x=0.15m/s,用于精确对齐阶段 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{行为树整体结构}

行为树采用三阶段顺序执行的Sequence结构,每个阶段开始前通过SetBlackboard切换控制器:

\begin{lstlisting}[language=XML]
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <Sequence name="MultiControllerNav">
      <!-- 阶段1: 快速接近 (FollowPath) -->
      <!-- 阶段2: 慢速精调 (SlowFollowPath) -->
      <!-- 阶段3: 精确对齐 (StanleyFollowPath) -->
    </Sequence>
  </BehaviorTree>
</root>
\end{lstlisting}

\subsubsection{阶段一:快速接近(FollowPath控制器)}

第一阶段使用DWB快速配置控制器,以较高速度完成大部分路程:

\begin{lstlisting}[language=XML]
<!-- 动态设置控制器ID为FollowPath -->
<SetBlackboard output_key="controller_id" value="FollowPath"/>

<!-- 路径规划(带Fallback恢复机制) -->
<Fallback name="PlanFast">
  <ComputePathToPose goal="{goal}" path="{fast_path}"
                     planner_id="GridBased"/>
  <Sequence>
    <ClearEntireCostmap service_name="global_costmap/..."/>
    <Wait wait_duration="0.5"/>
    <ComputePathToPose goal="{goal}" path="{fast_path}"
                       planner_id="GridBased"/>
  </Sequence>
</Fallback>

<!-- 路径跟随(使用黑板中的controller_id) -->
<Fallback name="FollowFast">
  <FollowPath path="{fast_path}" controller_id="{controller_id}"/>
  <Sequence>
    <ClearEntireCostmap service_name="local_costmap/..."/>
    <Wait wait_duration="0.5"/>
    <FollowPath path="{fast_path}" controller_id="{controller_id}"/>
  </Sequence>
</Fallback>
\end{lstlisting}

关键设计点:(1) \texttt{SetBlackboard}将controller\_id设为"FollowPath",后续FollowPath节点通过\texttt{\{controller\_id\}}引用该值;(2) 路径规划和跟随都使用Fallback包装,失败时自动清除代价地图并重试,增强鲁棒性;(3) 此阶段使用DWB快速配置,以0.5m/s的速度高效完成长距离导航。

\subsubsection{阶段二:慢速精调(SlowFollowPath控制器)}

第二阶段切换到DWB慢速配置,配合SpeedController进一步限速:

\begin{lstlisting}[language=XML]
<!-- 动态切换控制器ID为SlowFollowPath -->
<SetBlackboard output_key="controller_id" value="SlowFollowPath"/>
<Wait wait_duration="0.3"/>

<!-- 重新规划路径 -->
<ComputePathToPose goal="{goal}" path="{slow_path}"
                   planner_id="GridBased"/>

<!-- 使用SpeedController限制速度范围 -->
<SpeedController min_rate="0.1" max_rate="0.3" filter_duration="0.5">
  <FollowPath path="{slow_path}" controller_id="{controller_id}"/>
</SpeedController>
\end{lstlisting}

关键设计点:(1) 通过SetBlackboard将controller\_id切换为"SlowFollowPath",\textbf{同一个FollowPath节点现在调用的是慢速DWB控制器};(2) Wait节点确保控制器切换后系统稳定;(3) SpeedController装饰节点将速度限制在0.1-0.3m/s范围内,filter\_duration=0.5s实现平滑过渡;(4) 此阶段重新规划路径,确保从当前位置到目标的最优路径。

\subsubsection{阶段三:精确对齐(StanleyFollowPath控制器)}

第三阶段切换到自定义Stanley控制器,利用其横向误差校正能力实现精确对齐:

\begin{lstlisting}[language=XML]
<!-- 动态切换控制器ID为StanleyFollowPath -->
<SetBlackboard output_key="controller_id" value="StanleyFollowPath"/>
<Wait wait_duration="0.3"/>

<Fallback name="FinalAdjust">
  <!-- 如果已到达目标,直接成功 -->
  <GoalReached/>

  <!-- 否则执行微调序列 -->
  <Sequence>
    <!-- 后退0.12m获得更好的接近角度 -->
    <BackUp backup_dist="0.12" backup_speed="0.03"
            time_allowance="6.0"/>
    <Wait wait_duration="0.3"/>

    <!-- 重新规划最终路径 -->
    <ComputePathToPose goal="{goal}" path="{final_path}"
                       planner_id="GridBased"/>

    <!-- 超低速精确跟随 -->
    <SpeedController min_rate="0.05" max_rate="0.15"
                     filter_duration="0.3">
      <FollowPath path="{final_path}" controller_id="{controller_id}"/>
    </SpeedController>
  </Sequence>
</Fallback>
\end{lstlisting}

关键设计点:(1) 切换到Stanley控制器,利用其$\delta = \theta_e + \arctan(k \cdot e_{ct}/v)$公式同时校正航向误差和横向偏差;(2) Fallback结构首先检查GoalReached,若已满足目标容差则跳过微调;(3) 若未到达,执行BackUp后退0.12m——这是精确停车的关键技巧,后退可以让机器人退出局部最优位置,获得更好的重新接近角度;(4) SpeedController将速度限制在0.05-0.15m/s的超低速范围,确保最终阶段的精确控制。

\subsubsection{动态控制器切换机制总结}

本行为树的核心点在于\textbf{通过Blackboard实现控制器ID的动态切换}:

\begin{enumerate}
\item \textbf{统一的FollowPath节点}:整个行为树中的所有FollowPath节点都使用\texttt{controller\_id="\{controller\_id\}"}引用黑板变量,而非硬编码控制器名称。
\item \textbf{阶段性切换}:每个阶段开始前通过\texttt{SetBlackboard output\_key="controller\_id" value="XXX"}修改黑板中的控制器ID。
\item \textbf{三种控制器协同}:FollowPath(快速)$\to$SlowFollowPath(平稳)$\to$StanleyFollowPath(精确),各控制器在其擅长的阶段发挥作用。
\item \textbf{运行时决策}:控制器切换发生在行为树执行过程中,无需重启导航系统,实现了真正的动态切换。
\end{enumerate}

这种设计思想是"物尽其用"——快速阶段使用响应快、效率高的DWB控制器;接近目标时切换到慢速配置确保平稳;最终对齐使用具有横向误差校正能力的Stanley控制器提高精度。通过行为树的模块化设计,这三种控制器被有机地组合在一起,形成完整的精确停车解决方案。

%--------------------------------------------------------------------
\subsection{行为树配置与部署}

在Nav2参数文件中配置三种控制器和行为树:
\begin{lstlisting}
controller_server:
  ros__parameters:
    controller_plugins: ["FollowPath", "SlowFollowPath",
                         "StanleyFollowPath"]
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      max_vel_x: 0.5
      # ... 快速配置参数
    SlowFollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      max_vel_x: 0.3
      # ... 慢速配置参数
    StanleyFollowPath:
      plugin: "custom_controller::StanleyController"
      max_linear_speed: 0.15
      # ... Stanley配置参数

bt_navigator:
  ros__parameters:
    default_bt_xml_filename: "dynamic_multi_controller.xml"
\end{lstlisting}

\section{总结与展望}

\subsection{主要结论}

通过本项目的研究,得出以下主要结论:

\begin{enumerate}
\item \textbf{参数优化需要系统性方法}。Nav2涉及数十个相互关联的参数,孤立调整某个参数往往无法达到预期效果。本项目采用的控制变量法和自动化批量测试框架,是进行系统性参数优化的有效途径。

\item \textbf{控制器选择应匹配应用场景}。DWB适合通用场景,RPP适合追求效率的开阔环境,MPPI适合追求精度的复杂场景。没有"最优"控制器,只有"最适合"的控制器。

\item \textbf{行为树是实现复杂导航任务的利器}。通过行为树的模块化设计,可以将多种控制器、恢复行为、条件判断有机组合,实现比单一控制器更强大的导航能力。

\item \textbf{差速驱动机器人需要专门的控制算法}。将为Ackermann模型设计的Stanley算法直接应用于差速驱动底盘效果不佳,说明控制算法与机器人运动学模型的匹配至关重要。
\end{enumerate}

\subsection{未来展望}

本项目仍有若干方面值得进一步研究和改进:

\textbf{(1) Stanley控制器适配优化}。当前Stanley实现将转向角直接映射为角速度,未充分考虑差速驱动的运动学特性。后续可研究专门针对差速底盘的Stanley变体,或引入模型预测控制(MPC)框架提高适应性。

\textbf{(2) 动态障碍物避障}。当前测试环境为静态场景,实际仓库中存在移动的叉车、行人等动态障碍物。可结合MPPI控制器的预测能力和动态代价地图,提升动态环境下的导航安全性。

\textbf{(3) 多机器人协同调度}。单机器人导航是多机器人仓库系统的基础。后续可研究基于Nav2的多机器人路径规划、冲突检测与解决、任务调度等问题。

\textbf{(4) 实机验证与部署}。本项目所有实验均在仿真环境中进行。将优化后的参数配置和行为树部署到真实TIAGo机器人上,验证仿真结果的可迁移性,是走向实际应用的必经之路。

\textbf{(5) 深度学习增强}。探索将深度强化学习(DRL)用于控制器参数自适应调整,或使用神经网络替代传统的评价函数,可能进一步提升导航性能。

\end{document}
